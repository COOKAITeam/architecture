@startuml sequence_user_favorites

title COOKie MVP - User Favorites Flow\nPOST/DELETE /api/v1/users/me/favorites/{recipe_id}

actor "Authenticated User" as User
participant "FavoritesController" as Controller
participant "Auth Service" as Auth
database "PostgreSQL" as DB
database "Redis Cache" as Redis

== Add Recipe to Favorites ==

User -> Controller: POST /api/v1/users/me/favorites/{recipe_id}\nAuthorization: Bearer {ACCESS_TOKEN}

activate Controller

Controller -> Auth: validate_jwt(access_token)
activate Auth

alt Invalid or Expired Token
  Auth --> Controller: 401 Unauthorized

  Controller --> User: 401 Unauthorized\n{\n  "type": "https://cookie.com/errors/unauthorized",\n  "title": "Authentication Required",\n  "status": 401,\n  "detail": "Invalid or expired access token"\n}
  deactivate Auth
  deactivate Controller
end

Auth -> Auth: Decode JWT payload:\n{\n  "sub": "user-uuid-123",\n  "email": "user@example.com",\n  "role": "user"\n}

Auth --> Controller: User authenticated\nuser_id: "user-uuid-123"
deactivate Auth

Controller -> Controller: Validate recipe_id format:\n- UUID v4 format\n- Not null/empty

alt Invalid Recipe ID
  Controller --> User: 422 Unprocessable Entity\n{\n  "type": "https://cookie.com/errors/validation-error",\n  "title": "Validation Failed",\n  "status": 422,\n  "detail": "Invalid recipe ID format"\n}
  deactivate Controller
end

Controller -> DB: BEGIN TRANSACTION
activate DB

Controller -> DB: SELECT id, status, favorite_count\nFROM recipes\nWHERE id = ?\nFOR UPDATE  -- lock row for update

alt Recipe Not Found
  DB --> Controller: No rows returned

  Controller -> DB: ROLLBACK
  deactivate DB

  Controller --> User: 404 Not Found\n{\n  "type": "https://cookie.com/errors/not-found",\n  "title": "Recipe Not Found",\n  "status": 404,\n  "detail": "Recipe does not exist"\n}
  deactivate Controller
end

alt Recipe Not Published
  DB --> Controller: status = 'draft' or 'archived'

  Controller -> DB: ROLLBACK
  deactivate DB

  Controller --> User: 404 Not Found\n{\n  "type": "https://cookie.com/errors/not-found",\n  "title": "Recipe Not Found",\n  "status": 404\n}
  deactivate Controller
end

DB --> Controller: Recipe exists (status='published')

Controller -> DB: SELECT COUNT(*)\nFROM user_favorites\nWHERE user_id = ? AND recipe_id = ?

alt Favorite Already Exists
  DB --> Controller: COUNT = 1

  Controller -> DB: ROLLBACK
  deactivate DB

  Controller --> User: 409 Conflict\n{\n  "type": "https://cookie.com/errors/duplicate-favorite",\n  "title": "Already Favorited",\n  "status": 409,\n  "detail": "Recipe already in favorites"\n}
  deactivate Controller
end

DB --> Controller: COUNT = 0 (not favorited yet)

Controller -> DB: INSERT INTO user_favorites\n  (user_id, recipe_id, created_at)\nVALUES (?, ?, NOW())

Controller -> DB: UPDATE recipes\nSET favorite_count = favorite_count + 1\nWHERE id = ?

Controller -> DB: COMMIT TRANSACTION
deactivate DB

Controller -> Redis: DEL recipe:details:{recipe_slug}
activate Redis
note right: Invalidate cached recipe\n(favorite_count changed)
Redis --> Controller: OK
deactivate Redis

Controller -> Redis: DEL user:favorites:{user_id}:*
activate Redis
note right: Invalidate user's\nfavorites list cache
Redis --> Controller: OK
deactivate Redis

Controller --> User: 201 Created\n{\n  "message": "Recipe added to favorites",\n  "favorite": {\n    "recipe_id": "recipe-uuid-456",\n    "created_at": "2025-10-18T12:00:00Z"\n  },\n  "new_favorite_count": 3422\n}

deactivate Controller

== Remove Recipe from Favorites ==

User -> Controller: DELETE /api/v1/users/me/favorites/{recipe_id}\nAuthorization: Bearer {ACCESS_TOKEN}

activate Controller

Controller -> Auth: validate_jwt(access_token)
activate Auth
Auth --> Controller: User authenticated\nuser_id: "user-uuid-123"
deactivate Auth

Controller -> DB: BEGIN TRANSACTION
activate DB

Controller -> DB: SELECT id, favorite_count\nFROM recipes\nWHERE id = ?\nFOR UPDATE

alt Recipe Not Found
  DB --> Controller: No rows

  Controller -> DB: ROLLBACK
  deactivate DB

  Controller --> User: 404 Not Found
  deactivate Controller
end

DB --> Controller: Recipe exists

Controller -> DB: DELETE FROM user_favorites\nWHERE user_id = ? AND recipe_id = ?\nRETURNING created_at

alt Favorite Not Found
  DB --> Controller: No rows deleted

  Controller -> DB: ROLLBACK
  deactivate DB

  Controller --> User: 404 Not Found\n{\n  "type": "https://cookie.com/errors/not-found",\n  "title": "Favorite Not Found",\n  "status": 404,\n  "detail": "Recipe not in favorites"\n}
  deactivate Controller
end

DB --> Controller: Favorite deleted

Controller -> DB: UPDATE recipes\nSET favorite_count = GREATEST(favorite_count - 1, 0)\nWHERE id = ?
note right: GREATEST ensures\ncount never goes negative

Controller -> DB: COMMIT TRANSACTION
deactivate DB

Controller -> Redis: DEL recipe:details:{recipe_slug}
activate Redis
Redis --> Controller: OK
deactivate Redis

Controller -> Redis: DEL user:favorites:{user_id}:*
activate Redis
Redis --> Controller: OK
deactivate Redis

Controller --> User: 200 OK\n{\n  "message": "Recipe removed from favorites",\n  "new_favorite_count": 3420\n}

deactivate Controller

== Get User's Favorites List ==

User -> Controller: GET /api/v1/users/me/favorites?\n  page=1&per_page=20\nAuthorization: Bearer {ACCESS_TOKEN}

activate Controller

Controller -> Auth: validate_jwt(access_token)
activate Auth
Auth --> Controller: user_id: "user-uuid-123"
deactivate Auth

Controller -> Controller: Validate pagination:\n- page >= 1\n- per_page 1-100 (default 20)

Controller -> Controller: Build cache key:\nuser:favorites:user-uuid-123:page:1:limit:20

Controller -> Redis: GET user:favorites:user-uuid-123:page:1:limit:20
activate Redis

alt Cache Hit
  Redis --> Controller: Cached favorites list

  Controller --> User: 200 OK\nX-Cache: HIT\n{...favorites...}
  deactivate Redis
  deactivate Controller
end

Redis --> Controller: nil (cache miss)
deactivate Redis

Controller -> DB: SELECT r.id, r.slug, r.title, r.description,\n       r.image_url, r.cuisine_id, r.difficulty,\n       r.cooking_time, r.rating_avg, r.rating_count,\n       r.favorite_count, c.name as cuisine_name,\n       uf.created_at as favorited_at\nFROM user_favorites uf\nJOIN recipes r ON uf.recipe_id = r.id\nJOIN cuisines c ON r.cuisine_id = c.id\nWHERE uf.user_id = ?\n  AND r.status = 'published'\nORDER BY uf.created_at DESC\nLIMIT 20 OFFSET 0
activate DB

DB --> Controller: Favorites list (20 rows) + total count
deactivate DB

Controller -> Redis: SETEX user:favorites:...\n  TTL: 300
activate Redis
Redis --> Controller: OK
deactivate Redis

Controller --> User: 200 OK\nX-Cache: MISS\n{\n  "favorites": [\n    {\n      "recipe": {...full recipe data...},\n      "favorited_at": "2025-10-18T12:00:00Z"\n    },\n    ...\n  ],\n  "pagination": {\n    "page": 1,\n    "per_page": 20,\n    "total_pages": 15,\n    "total_count": 287\n  }\n}

deactivate Controller

== Database Schema ==

note over DB
**user_favorites table:**

CREATE TABLE user_favorites (
  user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
  recipe_id UUID NOT NULL REFERENCES recipes(id) ON DELETE CASCADE,
  created_at TIMESTAMP NOT NULL DEFAULT NOW(),

  PRIMARY KEY (user_id, recipe_id)
);

CREATE INDEX idx_user_favorites_user_id
  ON user_favorites(user_id);

CREATE INDEX idx_user_favorites_recipe_id
  ON user_favorites(recipe_id);

CREATE INDEX idx_user_favorites_created_at
  ON user_favorites(created_at DESC);

**Benefits:**
- Composite primary key prevents duplicates
- CASCADE delete removes favorites when user/recipe deleted
- Indexes for fast lookups both ways
- created_at for sorting (most recent first)
end note

== Error Scenarios ==

note over User, Redis
  **Common Errors:**

  **401 Unauthorized:**
  - Missing or invalid JWT token
  - Expired access token
  - User account deactivated

  **404 Not Found:**
  - Recipe doesn't exist (POST/DELETE)
  - Recipe not published (POST/DELETE)
  - Favorite doesn't exist (DELETE only)

  **409 Conflict:**
  - Recipe already favorited (POST only)
  - Duplicate request (race condition)

  **422 Unprocessable Entity:**
  - Invalid recipe_id format
  - Invalid pagination parameters

  **500 Internal Server Error:**
  - Database transaction failure
  - Deadlock (concurrent favorites)
  - Cache invalidation failure (non-blocking)

  **Rate Limiting:**
  - 100 favorite/unfavorite actions per hour per user
  - 429 Too Many Requests if exceeded
  - Prevents spam/bot behavior
end note

== Optimistic UI Updates ==

note over User, Controller
  **Frontend Pattern:**

  For better UX, implement optimistic updates:

  **Add Favorite:**
  1. Client immediately shows "favorited" state
  2. Increment favorite_count locally (+1)
  3. Send POST request in background
  4. If request fails → revert UI state

  **Remove Favorite:**
  1. Client immediately shows "unfavorited" state
  2. Decrement favorite_count locally (-1)
  3. Send DELETE request in background
  4. If request fails → revert UI state

  **Benefits:**
  - Instant feedback (no loading spinner)
  - Perceived performance improvement
  - Graceful error handling

  **Implementation:**
  - Use React Query / SWR for state management
  - Optimistic mutations built-in
  - Automatic rollback on error
end note

@enduml
