@startuml Sequence_User_Search_Recipe
!theme spacelab

title Sequence Diagram: User Searches and Views Recipe

actor "Пользователь" as User
participant "Web/Mobile App" as App
participant "API Gateway" as Gateway
participant "Auth Service" as Auth
participant "Recipe Service" as RecipeService
participant "Search Service" as SearchService
participant "Cache (Redis)" as Cache
participant "Recipe DB" as DB
participant "User Service" as UserService
participant "Analytics Service" as Analytics
participant "File Storage (S3)" as Storage

autonumber

== Аутентификация (опционально) ==
User -> App: Открывает приложение
App -> Gateway: GET /api/v1/auth/me\nAuthorization: Bearer <token>
Gateway -> Auth: Проверить JWT токен
Auth -> Cache: Проверить сессию
Cache --> Auth: Сессия валидна
Auth --> Gateway: User ID + роли
Gateway --> App: Данные пользователя
App --> User: Показывает главную страницу

== Поиск рецептов ==
User -> App: Вводит поисковый запрос:\n"паста карбонара веган"
App -> Gateway: GET /api/v1/recipes/search?\nq=паста карбонара веган&\ndietary_tags[]=vegan&\nlimit=20
Gateway -> Auth: Валидировать токен
Auth --> Gateway: OK
Gateway -> RecipeService: Переадресовывает запрос
RecipeService -> SearchService: Выполнить поиск с фильтрами

alt Кэш существует
    SearchService -> Cache: GET search:паста_карбонара_веган:vegan
    Cache --> SearchService: [Кэшированные результаты]
else Кэш отсутствует
    SearchService -> DB: SELECT * FROM recipes\nWHERE to_tsvector(title || ' ' || description)\n@@@ plainto_tsquery('паста карбонара веган')\nAND 'vegan' = ANY(dietary_tags)\nLIMIT 20
    DB --> SearchService: [Результаты из БД]
    SearchService -> UserService: GET /api/v1/users/{userId}/preferences
    UserService --> SearchService: Предпочтения пользователя
    SearchService -> SearchService: Персонализировать\nрезультаты по предпочтениям
    SearchService -> Cache: SET search:паста_карбонара_веган:vegan\n[Результаты] TTL=300s
end

SearchService --> RecipeService: [Отсортированные результаты]
RecipeService -> Analytics: Публиковать событие:\n{type: "search", query: "...", userId, results_count}
RecipeService --> Gateway: [20 рецептов с метаданными]
Gateway --> App: JSON Response
App --> User: Показывает список рецептов

== Просмотр карточки рецепта ==
User -> App: Кликает на рецепт\n"Веганская паста карбонара"
App -> Gateway: GET /api/v1/recipes/{recipeId}
Gateway -> Auth: Валидировать токен
Auth --> Gateway: OK
Gateway -> RecipeService: Получить детали рецепта

RecipeService -> Cache: GET recipe:{recipeId}
alt Кэш существует
    Cache --> RecipeService: [Данные рецепта из кэша]
else Кэш отсутствует
    RecipeService -> DB: SELECT r.*, \narray_agg(i.*) as ingredients,\narray_agg(c.*) as categories\nFROM recipes r\nJOIN recipe_ingredients ri ON r.id = ri.recipe_id\nJOIN ingredients i ON ri.ingredient_id = i.id\nJOIN recipe_categories rc ON r.id = rc.recipe_id\nJOIN categories c ON rc.category_id = c.id\nWHERE r.id = {recipeId}\nGROUP BY r.id
    DB --> RecipeService: [Полные данные рецепта]
    RecipeService -> Cache: SET recipe:{recipeId}\n[Данные] TTL=600s
end

RecipeService -> Storage: GET image URLs
Storage --> RecipeService: [Signed URLs для изображений]

RecipeService -> DB: UPDATE recipes\nSET view_count = view_count + 1\nWHERE id = {recipeId}
RecipeService -> Analytics: Публиковать событие:\n{type: "recipe_view", recipeId, userId, timestamp}

RecipeService --> Gateway: [Полные данные рецепта +\nингредиенты + категории + изображения]
Gateway --> App: JSON Response
App --> User: Показывает полную\nкарточку рецепта с фото,\nингредиентами, шагами, КБЖУ

note right of Analytics
  События асинхронно обрабатываются
  для построения аналитики:
  - Популярные поисковые запросы
  - Конверсия поиск → просмотр
  - Время на странице рецепта
end note

@enduml
